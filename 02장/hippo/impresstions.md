# 인상 깊은 내용

## 컴파일 시간 의존성과 실행 시간 의존성

어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.

코드의 의존성은 실행 시점의 의존성이 서로 다를 수 있다!!

클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.

**유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다!!**

다만, 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해햐기 어려워 진다.

하지만 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다.

이와 같은 의존성의 양면성은 설계가 트레이드 오프의 산물이라는 사실을 보여준다.

설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라!!

반면 유연성을 억제하면 코드를 이애하고 디버깅하지는 쉬워지지만 재사용성과 확장 가능성은 낮아진다는 사실도 기억하라!!

---

## 다형성

**동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 다형성이라 부른다!!**

다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.

다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.

**다시 말해 인터페이스가 동일해야 한다는 것이다.**

---

## 트레이드오프

구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다.

모든 코드에는 합당한 이유가 있어야 한다.

아주 사소한 결정이더라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다. 고민하고 트레이드오프하라!!

---

### 합성

인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 부른다.

합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.

인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.

또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.

상속은 클래스를 통해 강하게 결홥되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다.

따라서 재사용을 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.

---

이번 장에서는 책을 읽고 인상 깊었던 내용들을 추려보았습니다.

위 내용들 중 제일 인상 깊은 내용은 트레이드오프였습니다.

결국 객체 지향 프로그래밍을 위한 코드를 작성함에 있어서도 사소한 코드라도 합당한 이유가 모두 존재해야하며, 항상 트레이드오프하려 노력해야겠다는 생각이 들었습니다.