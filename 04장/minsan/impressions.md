`결합도`와 `응집도`에 대해서 두루뭉실하게 이해하고 있었는데, 이번 장에서 이와 관련하여 예시와 함께 명확하게 설명해줘서 관련 개념을 바로 잡을 수 있었다.

결국 가장 중요한 것은 객체를 설계함에 있어서 `객체의 행동`에 초점을 맞추고, **_"책임이 무엇인가"_** 에 대한 질문을 가장 먼저 던져야 한다는 것이다.

만일 **_"데이터가 무엇인가"_** 라는 질문으로 설계를 시작하면 캡슐화를 위반하기 쉬워지고, 이는 결국 `낮은 응집도`와 `높은 결합도`를 갖는 설계를 만들어낼 가능성이 커질 것이다.

앞의 장들에서 강조했던 **`"협력"에 집중하고, 이러한 협력에 필요한 "책임"과 "역할"에 집중하는 것`** 이 매우 중요함을 다시 한번 상기할 수 있었다.

---

# 메서드 시그니처도 인터페이스 (= 메서드 시그니처로도 구현이 노출될 수 있다)

`getter` 혹은 `setter`가 아닌 **"하나의 책임"** 을 담당하는 메서드라고 하더라도, **메서드 시그니처(= 인터페이스)를 통해**서 `구현`이 노출될 수도 있다.

특히 이번 장에서는 `메서드 시그니처(= 인터페이스)로 구현이 노출되는 경우`에 대해서 두 가지 케이스를 확인할 수 있었다.

1. `파라미터 타입`을 통해 노출되는 경우
2. `메서드 명`을 통해 노출되는 경우

### 파라미터 타입으로 노출

`Movie` 객체는 **할인 적용 가능 여부를 판단할 책임**을 갖고 있다.  
하지만, 데이터 중심 설계에서 아래와 같은 시그니처로 인터페이스를 제공한다.

```java
public boolean isDiscountable(LocalDateTime whenScreened, int sequence)
```

> 👉🏻 즉, **할인 적용 가능 여부를 판단하는 과정(= `구현`)** 에 필요한 `상태`들을 **인터페이스에 그대로 노출시킨 것**이다.

이러한 상태 값들이 변할 때마다 이를 호출하는 객체들도 변하기 때문에, `캡슐화를 위반했다`고 볼 수 있다는 것이다.

```md
이렇게 파라미터 타입으로 상태 값이 노출되는 부분에 대해서는 그동안 깊이 생각을 안 했는데,
이번 장을 읽으면서 `파라미터 타입 또한 캡슐화 위반 조건에 포함될 수 있다`는 점을 깨달았다.
```

### 메서드 명으로 노출

`Movie` 객체는 **할인 정책을 적용한 결제 비용을 반환하는 책임**을 갖는다.  
하지만, 데이터 중심 설계에서는 아래와 같은 인터페이스를 제공한다.

```java
public Money calculateAmountDiscountedFee() { ... }
public Money calculatePercentDiscountedFee() { ... }
public Money calculateNoneDiscountedFee() { ... }
```

> 👉🏻 즉, **결제 비용을 계산하는 과정(= `구현`)** 에 필요한 **할인 정책(= `상태`)들**을 **인터페이스에 그대로 노출**시킨 것이다.

마찬가지로 만약 **할인 정책이 변하는 경우**, 이를 호출하는 객체에서도 수정이 필요하다.

이 부분을 읽으면서 특히 [프리코스 4주차 편의점 문제 풀이 과정](https://github.com/minSsan/java-convenience-store-7-minSsan/blob/main/src/main/java/store/controller/StoreController.java#L145-L161)에서 작성한 코드가 생각났다.  
해당 코드에 대해서도 한번 점검해보면 좋을 것 같다.

---

# 캡슐화: 변경될 수 있는 어떤 것이라도 감추는 것

캡슐화를 단순히 **객체의 인스턴스 변수를 감추는 것**이라고 오인하기 쉽다. _(👉🏻 `setter`, `getter` 남용 가능성으로 이어짐)_

하지만 _"변경될 수 있는 어떤 것이라도 감추는 것"_ 이라는 정의를 새로 정립함으로써, 앞으로는 **캡슐화에 대한 오해의 여지를 줄일 수 있을 것 같다**.

> 👉🏻 여기서 말하는 _"변경될 수 있는 어떤 것"_ 에는 `역할을 수행하는 데 필요한 구현`을 모두 포함될 수 있을 것이다.

---

# 데이터 중심이 아닌, 책임 중심으로 설계하라

이번 장을 통해서 **데이터 중심의 설계**가 `변화에 얼마나 취약한지`, 왜 `낮은 응집도와 높은 결합성`을 가질 수밖에 없는지 이해할 수 있었다.

결국 핵심은 _"객체에 어떤 데이터가 필요한지"_ 를 먼저 고려하는 것이 아니라, _"객체가 어떤 책임을 가져야 하는지"_ 를 먼저 고려하라는 것이다.

그리고 이 내용을 앞 장과 연결해서 정리하자면 다음과 같다.

```md
[ 올바른 객체지향 설계 과정 ]

1. `협력`을 가장 먼저 설계한다.

2. 그리고 이러한 협력에 필요한 `책임`(= 메시지)을 찾고,

3. 각 `책임`(= 메시지)이 어떤 역할에 적합한지 찾는

반복적인 과정이 필요하다.
```
