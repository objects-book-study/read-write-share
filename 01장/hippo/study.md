# Chapter 01. 객체 설계

**소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적이다!!**

---

## 01 - 티켓 판매 애플리케이션 구현하기

- 소극장에서 공연을 진행합니다.
- 관람객을 입장시키기 전에 이벤트 당첨 여부를 확인합니다.
- 이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후에 입장할 수 있습니다.
- 이벤트에 담첨되지 않은 관람객은 티켓을 구매해야 입장할 수 있습니다.
- 관람객은 소지품을 보관할 용도로 가방을 들고올 수 있다.

### 초기 설계
- 소극장은 관람객의 가방 안에 초대장이 들어있는지 확인합니다.
- 초대장이 들어 있다면 이벤트 당첨된 관람객이므로 판매원에게서 받은 티켓을 관람객의 가방 안에 넣어준다.
- 가방 안에 초대장이 없다면 티켓을 판매해야 한다. 이 경우 소극장은 관람객의 가방에서 티켓 금액만큼을 차감한 후 매표소에 금액을 중가시킨다.
- 마지막으로 소극장은 관람객의 가방 안에 티켓을 넣어주고 입장 절차를 마무리한다.

--- 

## 02 - 무엇이 문제인가?

### 소프트웨어 모듈의 세가지 목적!!

1. 실행 중에 제대로 동작하는 것
2. 변경을 위해 존재하는 것
3. 코드를 읽는 사람과 의사소통하는 것

위 목적에 비추어 봤을 때 초기 설계는 목표한 기능을 오류 없이 제대로 동작시키지만 변경 용이성과 읽는 사람과의 의사소통이라는 목적을 만족시키지는 못한다.


### 예상을 빗나가는 코드

현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건낸다.

티켓을 구매하는 관람객은 가방 안에서 돈을 직접 꺼내 판매원에게 지불한다.

판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건네고 관람객에게서 직접 돈을 받아 매표소에 보관한다.

But, 초기 코드에서는 관람객, 판매원 -> 소극장의 통제를 받는 수동적은 존재가 되었다.

해당 코드는 우리의 상식과는 다르게 동작해 이해하기 어렵게 만든다.


### 변경에 취약한 코드

관람객이 가방을 들고 있지 않다면? 관람객이 현금이 아니라 신용카드를 이용한다면? 판매원이 매표소 밖에서 티켓을 판매한다면?

이런 가정이 깨지는 순간 모든 코드가 일시에 흔들린다.

세부적인 사실 중 한 가지라도 바뀌면 해당 클래스뿐만 아니라 이 클래스에 의존하는 다른 클래스도 함께 변경해야 한다.

이처럼 다른 클래스가 의존하는 다른 클래스의 내부에 대래 더 많이 알면 알수록 변경하기 힘들어진다.

**이것은 객체 사이의 의존성과 관련된 문제다.**

변경에 취약한 코드를 방지하기 위하여 객체 사이의 의존성을 완전히 없애는 것은 정답이 아니다.

애플리케이션 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하면 된다!

의존성이 과한 경우를 기리켜 결합도가 높다고 말한다.

설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이다.

---

## 03 - 설계 개선하기

### 자율성을 높이자

**설계를 변경하기 어려운 이유**

Theater가 Audience와 TicketSeller뿐만 아니라 

Audience 소유의 Bag과 TikcetSeller가 근무하는 TikcetOffice까지 마음대로 접근할 수 있기 때문!

**해결방법**

Audience와 TickerSeller가 직접 Bag과 TicketOffice를 처리하는 자율적인 존재가 되도록 설계를 변경하는 것이다!

---

#### 캡슐화

개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화(encapsulation)라고 부른다.

캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다!

객슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 변경에 용이한 설계가 된다.

오직 객체의 인터페이스에만 의존하자!

객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 

변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다!

**변경이 용이한 코드를 위해서 객체는 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임지고 해결하는 자율적인 존재가 되어야 한다.**

---

### 캡슐화와 응집도

핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다!

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다고 한다!

자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.

객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다!!

외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길이다!

---

### 절차지향과 객체지향

**절차지향적 프로그래밍 (Procedural Programming)**

프로세스와 데이터를 별도의 모듈에 위치시키는 방식

절차적 프로그래밍은 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다!

프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약하다!


**객체지향 프로그래밍 (Object-Oriented Programming)**

데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식

훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다!

객체지향 코드는 자신의 문제를 스스로 처리해야 한다는 예상을 만족시켜주기 떄문에 이해하기 쉽고, 

객체 내부의 변경이 객체 외부에 파급되지 않도록 제어할 수 있기 때문에 변경하기가 수월하다.

---

### 책임의 이동 (shift of responsibility)

객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다.

따라서 각 객체는 자신을 스스로 책임진다.

객체지향 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체를 구성함으로써 완성된다.

객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다.

객체는 다른 객체와의 협력이라는 문맥 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 한다!

따라서 객체가 어떤 데이터를 가지느냐보다는 객체에 어떤 책임을 할당할 것이냐에 초점을 맞춰야 한다!


### 훌륭한 객체 지향 설계란??

설계를 어렵게 만드는 것은 의존성이다!

해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다!

불필요한 세부사항을 객체 내부로 캡숄화하는 것은 객체의 자율성을 높이고 응집고 높은 객체들의 공동체를 창조할 수 있게 한다!!!

**불필요한 세부사항을 캡슐화하는 자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계다.**


### 트레이드오프

1. 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
2. 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다.
3. 어떤 경우에도 모든 사람들을 만족시킬 수 있는 설계를 만들 수는 없다.

