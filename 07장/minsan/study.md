# Chapter 07: 객체 분해

한번에 다뤄야 하는 정보의 수를 줄이기 위해 본질적인 정보만 남기고 불필요한 세부 사항을 걸러내면, 문제를 단순화할 수 있을 것이다.

👉🏻 이처럼 **불필요한 정보를 제거**하고 현재의 문제 해결에 필요한 **핵심만 남기는** 작업을 **추상화**라고 한다.

가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 크기를 줄이는 것이다. _(= 분해)_

---

# 1. 프로시저 추상화와 데이터 추상화

- **프로시저 추상화**
  - 소프트웨어가 **무엇을 해야 하는지**를 추상화 _(doing)_
- **데이터 추상화**
  - 소프트웨어가 **무엇을 알아야 하는지**를 추상화 _(knowing)_

시스템을 분해하는 방법을 결정하려면 먼저 `프로시저 추상화`를 중심으로 할 것인지, `데이터 추상화`를 중심으로 할 것인지를 결정해야 한다.

1. `프로시저 추상화`로 결정했다면, **기능 분해**의 길로 들어서는 것
2. `데이터 추상화`로 결정했다면, 아래 두 가지 중 하나를 선택해야 함
   1. 데이터를 중심으로 **타입을 추상화** _(👉🏻 추상 데이터 타입)_
   2. 데이터를 중심으로 **프로시저를 추상화** _(👉🏻 객체지향)_

❓ 일반적으로 객체지향이 전통적인 기능 분해 방법에 비해 효과적이라고 말하는 이유는 무엇인가?

# 2. 프로시저 추상화와 기능 분해

## 메인 함수로서의 시스템

프로시저 중심의 기능 분해 관점에서, 시스템은 필요한 더 작은 작업으로 분해될 수 있는 하나의 **커다란 메인 함수**다.

- 전통적인 기능 분해 방법은 **하향식 접근법**을 따른다.  
   👉🏻 시스템을 구성하는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법

## 급여 관리 시스템

여기서는 급여 관리 시스템을 구현하기 위해 **기능 분해 방법**을 이용한다.

- **하향식 접근법**을 따르며, 최상위의 추상적인 함수 정의에서 출발한다.
- 기능 분해의 초점은, 하나의 문장으로 표현된 기능을 **여러 개의 더 작은 기능으로 분해하는 것**이다.

```
직원의 급여를 계산한다
```

> 급여 관리 시스템에 대한 추상적인 최상위 문장

기능 분해 방법에 따라서 좀 더 세분화된 절차로 구체화 한다.

```
직원의 급여를 계산한다
  사용자로부터 소득세율을 입력받는다
  직원의 급여를 계산한다
  양식에 맞게 결과를 출력한다
```

만약 좀 더 정제 가능한 문장이 존재하면, 동일한 과정을 거쳐 **구현이 가능할 정도로 충분히 저수준의 문장이 될 때까지** 기능을 분해한다.

```
직원의 급여를 계산한다
  사용자로부터 소득세율을 입력받는다
    "세율을 입력하세요: "라는 문장을 화면에 출력한다
    키보드를 통해 세율을 입력받는다
  직원의 급여를 계산한다
    전역 변수에 저장된 직원의 기본급 정보를 얻는다
    급여를 계산한다
  양식에 맞게 결과를 출력한다
    "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다
```

급여 관리 시스템을, 입력을 받아 출력을 생성하는 **커다란 하나의 메인 함수로 간주**하고 기능 분해를 시작했다는 점에 주목한다.

> 👉🏻 기능 분해 방법에서는 **기능을 중심으로 필요한 데이터를 결정**한다.

하지만 이 방식은 유지보수에 다양한 문제를 야기한다.

## 급여 관리 시스템 구현

급여 관리 시스템의 최상위 문장은 다음과 같다.

```
직원의 급여를 계산한다
```

이 문장은 하나의 메인 함수로 매핑된다.

```
직원의 급여를 계산한다
  사용자로부터 소득세율을 입력받는다
  직원의 급여를 계산한다
  양식에 맞게 결과를 출력한다
```

위의 세분화된 내용을 이용하여 메인 함수의 내부를 채운다.

```rb
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

def main(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end

def getTaxRate()
  print("세율을 입력하세요: ")
  return gets().chomp().to_f()
end

def calculatePayFor(name, taxRate)
  index = $employees.index(name)
  basePay = $basePays[index]
  return basePay - (basePay * taxRate)
end

def describeResult(name, pay)
  return "이름: #{name}, 급여: #{pay}"
end
```

👉🏻 `하향식 기능 분해`는 시스템을 최상위의 가장 추상적인 메인 함수로 정의하고, **메인 함수를 구현 가능한 수준까지 세부적인 단계로 분해**하는 방법이다.

## 하향식 기능 분해의 문제점

- 시스템은 하나의 메인 함수로 구성돼 있지 않다.
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에, 유연성과 재사용성이 저하된다.
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.

설계는 코드 배치 방법이며, 설계가 필요한 이유는 **변경에 대비하기 위한 것**이다.  
위 목록들을 통해 알 수 있듯, `하향식 접근법`과 `기능 분해`는 **변경에 취약한 설계**를 낳는다.

### 하나의 메인 함수라는 비현실적인 아이디어

대부분의 경우, 추가되는 기능은 최초에 배포된 **메인 함수의 일부가 아닐 것**이다.

- 유일한 메인 함수라는 개념은 의미가 없어지고, 시스템은 **여러 개의 동등한 수준의 함수 집합**으로 성장하게 될 것

따라서 하향식 접근법은 **하나의 알고리즘을 구현하거나 배치 처리를 구현**하기에는 적합하지만, 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다.

### 메인 함수의 빈번한 재설계

시스템 안에는 여러 개의 정상이 존재한다.

- 👉🏻 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하는 하향식 기능 분해의 경우, **새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야** 한다.

예를 들어 `모든 직원들의 기본급의 총합`을 구하는 기능이 추가됐다고 가정한다.

문제는 기존의 메인 함수는 직원 각각의 급여를 계산하는 것이 목적이므로, 전체 직원들의 기본급 총액을 계산하는 **`sumOfBasePays` 함수가 들어설 자리가 마땅치 않다.**

```rb
def main(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end
```

- `sumOfBasePays` 함수 _(= 전체 직원의 급여 총액 계산)_ 와 `main` 함수 _(= 개별 직원의 급여를 계산)_ 는 **개념적으로 동등한 수준의 작업**을 수행함

먼저 main 함수 안의 로직을 새로운 `calculatePay` 함수로 옮긴다.

```rb
def calculatePay(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end
```

```
def main(operation, args={})
  case(operation)
  when :pay then calculatePay(args[:name])
  when :basePay then sumOfBasePays()
  end
end
```

> **시스템은 여러 개의 정상으로 구성된다.**  
> 따라서 새로운 정상을 추가할 때마다 하나의 정상이라고 간주했던 main 함수의 내부 구현을 수정할 수밖에 없다.

### 비즈니스 로직과 사용자 인터페이스의 결합

하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 **입력 방법과 출력 양식을 함께 고민하도록** 강요한다.

- 급여를 계산하는 중요한 비즈니스 로직과, 소득 세율을 입력받아 결과를 화면에 출력한다는 사용자 인터페이스가 섞여 있음
- 즉, 사용자 인터페이스를 변경하는 경우, 비즈니스 로직까지 변경에 영향을 받게 됨

👉🏻 `관심사의 분리`라는 아키텍처 설계의 목적을 달성하기 어려움

### 성급하게 결정된 실행 순서

`하향식으로 기능을 분해하는 과정`은 설계를 시작하는 시점부터 **시스템이 무엇(what)을 해야 하는지**가 아니라, **어떻게(how) 동작해야 하는지**에 집중하도록 만든다.

> 앞서 살펴본 좋은 객체지향 설계 과정에서는, 무엇을 하는지를 기준으로 역할을 할당했음

이렇게 짜여진 코드는 **중앙집중 제어 스타일**의 형태를 띨 수 밖에 없다.

- **모든 중요한 제어 흐름의 결정이 상위 함수에서** 이뤄지고, 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출됨

문제는 `함수의 제어 구조`가 **빈번한 변경의 대상**이라는 것이다.

- <-> 객체지향은 함수 간의 호출 순서가 아니라, `객체 사이의 논리적인 관계`를 중심으로 설계를 이끌어 나간다.

> 하향식 설계와 관련된 모든 문제의 원인은 `결합도`이다.
>
> - 함수는 **상위 함수가 강요하는 문맥**에 강하게 결합된다.

### 데이터 변경으로 인한 파급효과

하향식 기능 분해의 가장 큰 문제점은, **어떤 데이터를 어떤 함수가 사용하고 있는지**를 추적하기 어렵다는 것이다.

- 특정 데이터가 변경되면, 모든 함수를 분석해서 영향도를 파악해야 한다.

데이터 변경으로 인한 영향을 최소화하려면, `데이터와 함께 변경되는 부분`과 `그렇지 않은 부분`을 **명확히 분리해야** 한다.

- 이를 위해 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고, 외부에서 제공되는 함수만 이용해 데이터에 접근해야 함
- 👉🏻 즉, 잘 정의된 퍼블릭 인터페이스를 통해 **데이터에 대한 접근을 통제해야 한다는 것**

## 언제 하향식 분해가 유용한가?

설계가 어느정도 안정화된 후에는 하향식 분해가 유용하다.

```
- 하향식은 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다.

- 이미 완료한 결과에 대한 명확한 아이디어를 가지고 있다면, 머릿속에 있는 것을 종이에 서술하기 위해 하향식을 사용할 수 있다.
```

> 실제로 동작하는 커다란 소프트웨어를 설계하는 데 적합한 방법은 아니다.  
> **이미 해결된** 알고리즘을 문서화하고 서술하는 데는 훌륭한 기법이다.

# 3. 모듈

## 정보 은닉과 모듈

시스템의 변경을 관리하는 기본적인 전략은 **함께 변경되는 부분을 하나의 구현 단위**로 묶고, **퍼블릭 인터페이스를 통해서만 접근하도록** 만드는 것

- 즉, 기능을 기반으로 시스템을 분해하는 것이 아닌, `변경의 방향`에 맞춰 시스템을 분해하는 것이다.
  - 낮은 응집도: 변경 지점을 한 곳에 집중
  - 낮은 결합도: 변경의 전파 최소화

> **정보 은닉**  
> 시스템을 모듈 단위로 분해하기 위한 기본 원리  
> 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다.

`기능 분해`는 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정이다.  
`모듈 분해`는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다.

모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.

1. **복잡성**  
   외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.

2. **변경 가능성**  
   변경 가능한 설계 결정이 외부에 노출될 경우, 실제로 변경이 발생할 때 파급효과가 커진다.  
   외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.

이때 비밀이 반드시 `데이터`일 필요는 없으며, `복잡한 로직`이나 `변경 가능성이 큰 자료구조`일 수도 있다.

급여 관리 시스템에서 외부로 감춰야 하는 비밀은 `직원 정보`와 관련된 것이다.  
따라서 모듈을 이용해 직원 정보라는 비밀을 내부로 감추고, 외부에 대해서는 퍼블릭 인터페이스만 노출시켜야 한다.

```rb
module Employees
  $employees = ["직원A", "직원B", "직원C", "직원D", "직원E", "직원F"]
  $basePays = [400, 300, 250, 1, 1, 1.5]
  $hourlys = [false, false, false, true, true, true]
  $timeCards = [0, 0, 0, 120, 120, 120]

  def Employees.calculatePay(name, taxRate)
    if (Employees.hourly?(name)) then
      pay = Employees.calculateHourlyPayFor(name, taxRate)
    else
      pay = Employees.calculatePayFor(name, taxRate)
    end
  end

  def Employees.hourly?(name)
    return $hourly[$employees.index(name)]
  end

  def Employees.calculateHourlyPayFor(name, taxRate)
    index = $employees.index(name)
    basePay = $basePays[index] * $timeCards[index]
    return basePay - (basePay * taxRate)
  end

  def Employees.calculatePayFor(name, taxRate)
    return basePay - (basePay * taxRate)
  end

  def Employees.sumOfBasePays()
    result = 0
    for name in $employees
      if (not Employees.hourly?(name)) then
        result += $basePays[$employees.index(name)]
      end
    end
    return result
  end
end
```

## 모듈의 장점과 한계

모듈의 장점은 다음과 같다.

### 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다

모듈을 사용하면 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 내부로 제한할 수 있다.  
모듈은 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에, 코드를 수정하고 디버깅하기가 더 용이하다.

### 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다

`Employees` 모듈은 비즈니스 로직과 관련된 관심사만을 담당하며, 사용자 인터페이스와 관련된 관심사는 모두 `Employees` 모듈을 사용하는 `main` 함수 쪽에 위치한다.

### 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다

모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.

- 모듈 내부는 `높은 응집도`를 유지
- 모듈과 모듈 사이에는 인터페이스를 통해서만 통신하므로, `낮은 결합도`를 유지

또한, 모듈은 기능이 아니라 **데이터를 중심으로 시스템을 분해하는 것**이다.

- 감춰야 할 데이터를 결정하고, 이 데이터를 조작하는 데 필요한 함수를 결정

> 모듈의 가장 큰 단점은 **`인스턴스`의 개념을 제공하지 않는다**는 것이다.

`Employees` 모듈은 단지 회사에 속한 모든 직원 정보를 갖는 모듈일 뿐이다.  
더 높은 수준의 추상화를 위해서는 직원 전체가 아닌 **개별 직원을 독립된 단위로** 다룰 수 있어야 한다.

이를 만족시키기 위해 등장한 개념이 `추상 데이터 타입`이다.

# 4. 데이터 추상화와 추상 데이터 타입

`추상 데이터 객체`를 사용할 때, 프로그래머는 오직 **객체가 외부에 제공하는 행위에만 관심**을 가지며 행위가 구현되는 **세부적인 사항에 대해서는 무시**한다.

루비의 Struct를 이용해 개별 직원을 위한 `추상 데이터 타입`을 구현한다.

```rb
Employee = Struct.new(:name, :basePay, :hourly, :timeCard) do
End
```

추상 데이터 타입에 적용할 수 있는 오퍼레이션을 결정해야 한다.

- `Employee` 타입의 주된 행동은 **직원의 유형에 따라 급여를 계산**하는 것
  - `calculatePay` 오퍼레이션 추가

따라서 직원을 지정해야 했던 모듈 방식보다, `추상 데이터 타입에 정의된 오퍼레이션의 시그니처`가 **더 간단하다**는 것을 알 수 있다.

추상 데이터 타입은 사람들이 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준을 향상시킨다.

- 일상에서 `Employee`라고 말할 때는 상태와 행위를 갖는 독립적인 객체

> 하지만, 추상 데이터는 여전히 **데이터와 기능을 분리**해서 바라본다.  
>  👉🏻 추상 데이터는 말 그대로 시스템의 상태를 저장할 데이터를 표현한다.  
>  👉🏻 추상 데이터 타입으로 표현된 데이터를 이용해서 기능을 구현하는 **핵심 로직은 추상 데이터 타입 외부에** 존재한다.

# 5. 클래스

## 클래스는 추상 데이터 타입인가?

명확한 의미에서 추상 데이터 타입과 클래스는 동일하지 않다.

- **클래스** - `상속`과 `다형성`을 지원
- **추상 데이터 타입** - 이를 지원하지 못함

> `추상 데이터 타입`은 **타입을 추상화**한 것  
> `클래스`는 **절차를 추상화**한 것

하나의 타입처럼 보이는 `Employee` 내부에는 **정규 직원**과 **아르바이트 직원**이라는 두 개의 타입이 공존하고 있다.

- 이처럼 **하나의 대표적인 타입이 다수의 세부적인 타입을 감추기** 때문에 이를 `타입 추상화`라고 한다.

⭐️ `타입 추상화`는 개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄한다.

그에 반해 `객체지향`은 정규 직원과 아르바이트 직원이라는 **두 개의 타입을 명시적으로 정의**하고, 두 직원 유형과 관련된 **오퍼레이션의 실행 절차를 두 타입에 분배**한다.

| 타입 추상화                                             | 객체지향                                          |
| ------------------------------------------------------- | ------------------------------------------------- |
| 오퍼레이션 내부에서 타입에 따라 절차를 서로 다르게 결정 | 서로 다른 타입은 서로 다른 오퍼레이션 절차를 가짐 |

> 동일한 메시지에 대해 서로 다르게 반응하는 것 _(= 다형성)_

## 변경을 기준으로 선택하라

타입을 기준으로 절차를 추상화하지 않았다면, 그것은 객체지향 분해가 아니다.

### Q. 그렇다면 항상 절차를 추상화하는 객체지향 설계 방식을 따라야 하는가?

설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.

즉, **변경의 압력**이 `타입 추가`에 관한 것인지, `오퍼레이션 추가`에 관한 것인지에 따라 달라진다.

| 타입 추가 | 오퍼레이션 추가  |
| --------- | ---------------- |
| 객체지향  | 추상 데이터 타입 |

> - 변경의 주된 압력이 **타입을 추가하는 것**인 경우 👉🏻 `객체지향`
>   - 추상 데이터 타입에서 새로운 타입을 추가하려면, 타입을 체크하는 클라이언트 코드를 일일이 찾아 수정해야 함
>   - 반면, 객체지향에서는 클라이언트 코드를 수정할 필요가 없음 _(새로운 클래스를 상속 계층에 추가하면 됨)_
> - 변경의 주된 압력이 **오퍼레이션을 추가하는 것**인 경우 👉🏻 `추상 데이터 타입`
>   - 객체 지향에서 새로운 오퍼레이션을 추가하려면, 상속 계층에 속하는 모든 클래스를 한번에 수정해야 함
>   - 반면, 추상 데이터 타입에서는 전체 타입에 대한 구현 코드가 하나의 구현체 내에 포함되어 있기 때문에, 새로운 오퍼레이션을 추가하는 작업이 간단하다.

## 협력이 중요하다

객체지향에서 중요한 것은 `역할`, `책임`, `협력`이다.  
객체지향은 기능을 수행하기 위해 **객체들이 협력하는 방식**에 집중한다.

- 협력이라는 문맥을 고려하지 않고, 객체를 고립시킨 채 오퍼레이션의 구현 방식을 타입별로 분배하는 것은 올바른 접근법이 아니다.

객체를 설계하는 방법은 `책임 주도 설계`의 흐름을 따른다. _(3장)_
