# 클래스는 추상 데이터 타입이 아니다

추상 데이터 타입은 c++에서 살펴본 구조체와 유사한 느낌으로 이해하면 쉽다.

- 즉, **추상 데이터 타입은 `상속`과 `다형성`을 지원하지 않는다.**

추상 데이터 타입은 **타입을 추상화** 하고, 클래스는 **절차를 추상화** 한다.

# 타입 추상화 vs 객체지향

**타입 추상화**는 **개별 오퍼레이션이 `모든 타입에 대한 구현`을 포함**한다.

- 하나의 타입 안에 전체 타입을 감춘다.

**객체지향**은 **서로 다른 타입을 명시적으로 정의**하고, 두 유형과 관련된 **오퍼레이션을 두 타입에 분배**한다.

- 타입을 기준으로 오퍼레이션을 묶는다.

# 객체지향 위반 신호

클래스 내부에서 **인스턴스 변수**에 저장된 값을 기반으로 **절차를 구분**하는 방식 _(= 타입 추상화)_ 이 사용되었다면, 이는 객체지향을 위반했다고 볼 수 있다.

# 추상 데이터 타입이 항상 안 좋은 것이 아니다

**변경의 방향성**에 따라서 `객체지향`과 `추상 데이터 타입` 중 더 적절한 것을 선택해야 한다.

- **새로운 타입**을 빈번하게 추가해야 된다면 `객체지향의 클래스` 구조를,
- **새로운 오퍼레이션**을 빈번하게 추가해야 된다면 `추상 데이터 타입`을

선택하는 것이 현명하다.

> - 변경의 주된 압력이 **타입을 추가하는 것**인 경우 👉🏻 `객체지향`
>   - 추상 데이터 타입에서 새로운 타입을 추가하려면, 타입을 체크하는 클라이언트 코드를 일일이 찾아 수정해야 함
>   - 반면, 객체지향에서는 클라이언트 코드를 수정할 필요가 없음 _(새로운 클래스를 상속 계층에 추가하면 됨)_
> - 변경의 주된 압력이 **오퍼레이션을 추가하는 것**인 경우 👉🏻 `추상 데이터 타입`
>   - 객체 지향에서 새로운 오퍼레이션을 추가하려면, 상속 계층에 속하는 모든 클래스를 한번에 수정해야 함
>   - 반면, 추상 데이터 타입에서는 전체 타입에 대한 구현 코드가 하나의 구현체 내에 포함되어 있기 때문에, 새로운 오퍼레이션을 추가하는 작업이 간단하다.

# 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화하라

객체가 참여할 협력을 결정하고, 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민하라.  
**그 책임을 `다양한 방식`으로 수행해야 할 때만** 타입 계층 안에 각 절차를 추상화하라.

- `타입 계층`과 `다형성`은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며, **그 자체가 목적이 되어서는 안 된다.**
