## 객체를 가지고 있기 때문에 메시지를 보내는 것이 아니다. 메시지를 전송하기 때문에 객체를 갖게 된 것이다.

협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후에 메시지를 선택하는 것이 아니다.  
메시지를 결정한 후에 객체를 선택해야 한다.

> 👉🏻 메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것이다.

객체에게 적절한 책임을 할당하기 위해서는

1. 협력이라는 문맥을 고려해야 한다.
2. 협력이라는 문맥에서 적절한 책임이란, 곧 클라이언트의 관점에서 적절한 책임을 의미한다.
3. 클라이언트가 전송할 메시지를 결정한 후에야 비로소 객체의 상태를 저장하는데 필요한 내부 데이터에 관해 고민하기 시작한다.

앞서 계속 강조했던 내용을 이번 장에서도 반복해서 설명하고 있다.  
결국에는 협력이라는 문맥을 먼저 고려해야 하고, 그 속에서 필요한 메시지와 이를 처리할 객체를 결정해야 한다는 것이다.

이전에는 어떤 클래스가 필요할지 먼저 고민해보고, 해당 클래스가 어떤 데이터를 가져야할지 고민했었다. 하지만, 이번에 오브젝트 책을 읽고나서는 **협력이라는 문맥 안에 필요한 책임이 무엇인지**를 먼저 고민하는 것이 매우 중요하다는 점을 계속 상기할 수 있었다.

## 객체들의 책임이 어느정도 정리될 때까지 객체 내부 상태에 대해 관심을 가지지 말 것

하나의 객체를 정의하고 나면, 해당 객체가 가져야할 데이터에 대해서 고민했다.

하지만 이 문구를 읽고 나서, **객체들의 개략적인 책임이 결정된 후에** 각 객체가 책임을 처리할 때 필요한 데이터를 정의하는 것이 올바른 객체의 설계 과정이라는 것을 인지할 수 있었다.

> 👉🏻 객체가 결정되고 나서 곧바로 해당 객체가 가져야할 데이터를 결정하려는 강박을 내려놓는 자세가 필요할 것 같다.

## 도메인 개념들을 책임 할당의 대상으로 사용한다.

도메인은 **설계를 시작하기 위해 참고할 수 있는 개념들의 모음** 정도로 생각해야 한다.  
도메인은 책임을 할당받을 `객체의 종류` 및 `관계`에 대한 정보를 제공한다는 점에서 의미가 있는 것이다.

그리고 올바른 도메인 모델은 존재하지 않는다. 똑같은 요구사항에서도 도메인은 여러 방식으로 설계될 수 있다.

👉🏻 특히, 유연성이나 재사용성 등과 같이 실제 **코드를 구현하면서 얻게 되는 통찰**이 역으로 **도메인에 대한 개념을 바꾸기도** 한다.

> 도메인을 완벽하게 설계 해야겠다는 강박을 내려놓을 필요가 있단 생각이 들었다.  
> 지난번에 프리코스 4주차 편의점 문제의 도메인을 설계하다가 실패해서 그런지 이 부분이 인상깊었다.

## 코드를 작성하는 순간마다 `LOW COUPLING`과 `HIGH COHESION`의 관점에서 설계 품질을 검토한다

책에서는 이 내용을 강조한다.  
그리고 이를 점검하는 방법은 **"변화가 발생했을 경우를 고려하는 것"** 이라는 생각이 들었다.

응집도와 결합도는 변화에 유연성있게 대처하기 위해 등장한 개념이다.

> 👉🏻 따라서, **특정 요구사항이 바뀔 때** / **특정 객체의 구현이 변경되었을 때** 외부에 어떤 추가 변경이 발생하는지 살펴보는 것이 각각 `응집도` / `결합도`를 점검하는 방법이 될 수 있겠다는 생각이 든다.

만약 여러 대안 중에서 하나를 선택해야 한다면, **응집도가 더 높으며 결합도는 더 낮은 방법**을 선택해야 한다는 것이다.  
결국 트레이드오프를 위해 필요한 핵심 개념들이라는 생각이 든다.

## 코드를 통해 변경의 이유를 파악할 수 있는 방법

설계를 개선하기 위해 필요한 가장 첫 번째 작업은 `변경의 이유가 둘 이상인 클래스를 찾는 것`이다. _(= 응집도가 낮은 클래스)_

변경의 이유가 두 개 이상인 클래스를 찾을 수 있는 증상들은 아래와 같다.

```
[ 코드 변경의 원인이 두 개 이상인 클래스 찾기 ]

1. 인스턴스 변수가 초기화되는 시점 살펴보기
- 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
- 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고, 일부는 초기화되지 않은 상태로 남겨진다.
    👉🏻 함께 초기화되는 속성을 기준으로 코드(클래스)를 분리해야 한다.

2. 메서드들이 인스턴스 변수를 사용하는 방식 살펴보기
- 응집도가 높은 클래스는 모든 메서드가 객체의 모든 속성을 사용한다.
- 응집도가 낮은 클래스는 메서드들이 사용하는 속성에 따라 그룹이 나뉜다.
    👉🏻 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.
```

## GRASP 패턴은 _어떤 객체에 어떤 책임을 할당할 것인지_ 에 대한 해답을 제시한다

- `INFORMATION EXPERT` 패턴 _(👉🏻 어느 객체에 책임을 할당할 것인가)_
  - 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 책임을 할당한다.
  - 이 패턴을 따르면 **정보와 행동을 최대한 가까운 곳에 위치**시켜 `캡슐화`를 유지할 수 있다. _(높은 응집도)_
- `LOW COUPLING` 패턴
  - 의존성을 낮추고, 변화의 영향을 줄이며, 재사용성을 증가시키기 위한 패턴
- `HIGH COHESION` 패턴
  - 복잡성을 관리할 수 있는 수준으로 유지하기 위해서는, 높은 응집도를 유지할 수 있게 책임을 할당해야 한다.
- `CREATOR` 패턴 _(👉🏻 객체를 생성할 책임을 누구에게 할당할 것인가)_
  - 이미 관계가 형성되어 있는 객체에게 생성 책임을 할당해야 한다.
- `POLYMORPHISM` 패턴
  - **객체의 타입에 따라 변하는 로직**이 있을 때, 타입을 명시적으로 정의하고 **각 타입에 다형적으로 행동하는 책임을 할당해야** 한다.
  - ⭐️ **객체의 타입을 검사해서** 타입에 따라 여러 대안들을 수행하는 `조건적인 논리`를 사용하지 말라고 경고한다. 그 대신, `다형성`을 이용해 새로운 변화를 다루기 쉽게 확장해야 한다.
- `PROTECTED VARIATIONS` 패턴
  - 클래스를 변경에 따라 분리하고, **변화가 예상되는 지점**을 캡슐화한다. _(by 인터페이스)_
    - **하나의 클래스가 여러 타입의 행동을 구현하고 있는 것**처럼 보인다면, `클래스를 분해하고 책임을 분산`시켜야 한다.
    - **예측 가능한 변경으로인해 여러 클래스들이 불안정**해진다면, 안정적인 `인터페이스 뒤로 변경을 캡슐화`해야 한다.
